/*👋 문제
N명의 학생들을 키 순서대로 줄을 세우려고 한다. 각 학생의 키를 직접 재서 정렬하면 간단하겠지만, 마땅한 방법이 없어서 두 학생의 키를 비교하는 방법을 사용하기로 하였다. 그나마도 모든 학생들을 다 비교해 본 것이 아니고, 일부 학생들의 키만을 비교해 보았다.

일부 학생들의 키를 비교한 결과가 주어졌을 때, 줄을 세우는 프로그램을 작성하시오.
*/

/*👋 입력
첫째 줄에 N(1 ≤ N ≤ 32,000), M(1 ≤ M ≤ 100,000)이 주어진다. M은 키를 비교한 회수이다. 다음 M개의 줄에는 키를 비교한 두 학생의 번호 A, B가 주어진다. 이는 학생 A가 학생 B의 앞에 서야 한다는 의미이다.

학생들의 번호는 1번부터 N번이다.
*/

/*👋 출력
첫째 줄에 학생들을 앞에서부터 줄을 세운 결과를 출력한다. 답이 여러 가지인 경우에는 아무거나 출력한다.
*/

/*📚 위상 정렬
위상 정렬이란, 사이클이 없는 방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열하는 것을 의미한다. 다음 과정에서 각 노드가 큐에 들어온 순서가 곧 위상 정렬을 수행한 결과이다.

1. 진입차수 계산 - 각 정점의 진입차수(입력으로 들어오는 간선의 수)를 계산한다. 이는 각 정점이 몇 개의 선행 작업을 가지고 있는지를 의미한다.
2. 진입차수가 0인 정점 선택 - 진입차수가 0인 정점은 선행 작업이 없는 작업들을 의미한다. (선행으로 처리해야 할 정점을 의미)
3. 선택한 정점 제거 - 해당 작업을 완료시킨다.
4. 진입 차수 업데이트 - 선택한 정점을 제거한 후, 그와 연결된 정점들의 진입차수를 감소시킨다. 이는 선택한 작업으로 인해 선행 작업의 수가 줄어든 것을 반영하는 의미기도 하다.
5. 진입차수가 0인 정점 선택 및 제거 - 위의 2~4단계를 반복하여 진입차수가 0인 정점을 선택하고 제거한다. 이 과정을 모든 정점이 제거될 때까지 반복한다.
6. 결과반환 - 정점들을 제거한 순서대로 나열하여 위상 정렬의 결과를 반환한다.

*/

const fs = require("fs");
const input = fs
  .readFileSync(process.platform === "linux" ? "/dev/stdin" : "입력.txt")
  .toString()
  .trim()
  .split("\n");

function solution(data) {
  const [[N, _], ...arr] = data.map((el) => el.split(" ").map(Number));
  
  // 그래프 배열
  const graph = Array.from({ length: N + 1 }, () => []);
  // 진입차수 배열
  const rank = Array.from({ length: N + 1 }, () => 0);

  arr.forEach(([a, b]) => {
    // 선행 노드 a의 그래프 안에 노드 b 추가
    graph[a].push(b);
    // 1. 진입 차수 계산
    // 선행 노드 a가 존재하는 노드 b의 진입차수 증가 
    rank[b]++;
  });
  
  // queue 구현
  const queue = [];
  let queueIdx = 0;

  for (let i = 1; i < N + 1; i++) {
    // 2. 진입차수가 0인 정점 선택
    if (!rank[i]) queue.push(i);
  }

  const result = [];
  while (queueIdx < queue.length) {
    const node = queue[queueIdx++];
    // 3,5. 선택한 정점 제거
    result.push(node);
    // 4. 진입차수 업데이트 ->선택한 정점과 연결된 정점들의 진입차수 감소
    graph[node].forEach((next) => {
      rank[next]--;
      // 5. 진입차수가 0인 정점 선택
      if (!rank[next]) queue.push(next);
    });
  }
  
  // 6. 결과반환
  console.log(...result);
}

solution(input);